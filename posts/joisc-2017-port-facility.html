<p>First of all, if there are two different containers <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> such that <span class="math inline">\(A_i &lt; A_j &lt; B_i &lt; B_j\)</span>, they can’t be put in the same spot. So we can add an edge between them (graph is on nodes from <span class="math inline">\(1\)</span> to <span class="math inline">\(N\)</span>), which tells us that they must be assigned to different spots. After adding the edges properly, let’s say that the graph is bipartite and connected (if it’s not bipartite, then there is no way to choose spots for them). Then if we choose the spot for one container, then others’ will be determined automatically. And as there are two ways to choose the spot for first one, the answer is 2. (Well, you may want to ponder for a while if it’s not trivial for you that if the graph is bipartite, you can always manage the cargoes, it’s somewhat like a correct bracket sequence)</p>
<p>Now, if there are multiple components, all of which are bipartite, the answer is <span class="math inline">\(2^{\texttt{\#components}}\)</span>. All that remains is that we need to check if the graph is bipartite or not and if it’s bipartite, find the number of connected components. To do that, we will use segment tree to build a slightly different kind of graph. This graph has two kinds of edges – some edges will have 0 as weight meaning that the nodes at the two endpoints must have same color (same spot. From now on, if I say, “<span class="math inline">\(i\)</span>-th node’s color is white”, that means that the <span class="math inline">\(i\)</span>-th container is assigned to spot 1, and black, if I want to assign it to spot 2) and some edges will have 1, meaning that they must have different colors.</p>